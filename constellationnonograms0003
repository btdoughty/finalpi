#########################################################################################
#
#  Raspberry Pi Final Project
#
#  Constellation Nonograms
#
#  By:
#  Jalen Senones
#  Carmen Nicholson
#  Ben Doughty
#
#########################################################################################

import Tkinter as tk

# The starting point for the grid code comes from stackoverflow user fhdrsdg at
# http://stackoverflow.com/questions/26988204/using-2d-array-to-create-clickable-tkinter-canvas

# sets the number of rows and columns in the game
ROWS = 8
COLS = 16

# creates an array to store the information on whether or not each cell has been clicked
cells = [["empty" for i in range(COLS)] for i in range(ROWS)]

#sets the window size and border
bordersize = 80
windowheight = 480
windowwidth = 800

def click(event):
    # sets the size of each column and row
    col_width = 40
    row_height = 40
    
    # forces the grid to begin and end a distance from the edge of the window equal to the cell size (width & height)
    # ***question about this:  this does not make sense, it should be cols-1 and rows-1, but that does not work correctly.  why??***
    if event.x >= bordersize and event.x <= windowwidth-bordersize and event.y >= bordersize and event.y <= windowheight-bordersize:
            
        # The event.x and event.y return the coordinates of the cursor
        # By finding the floor of the coordinates divided by their respective boundary size,
        # we can define which column and row have been clicked
        # 1 is subtracted to correct for the empty border area
        col = (event.x - bordersize)//(col_width)
        row = (event.y - bordersize)//(row_height)

     
        # fills in the cell when it is clicked
        if cells[row][col] == "empty":
            cells[row][col] = gamewindow.create_rectangle((col)*col_width + bordersize, (row)*row_height + bordersize, (col+1)*col_width + bordersize, (row+1)*row_height + bordersize, fill="black")
        # clears a filled tile if it is clicked
        else:
            gamewindow.delete(cells[row][col])
            cells[row][col] = "empty"

# creates the window, a canvas and the mouse click event binding
root = tk.Tk()
gamewindow = tk.Canvas(root, width=windowwidth, height=windowheight, borderwidth=5, background='white')
gamewindow.pack()
gamewindow.bind("<Button-1>", click)

# draws a grid for the game space
for i in range (COLS):
    for j in range (ROWS):
        gamewindow.create_rectangle(bordersize + 40*i,bordersize + 40*j,bordersize + 40*(i+1),bordersize + 40*(j+1))


# Sets nonogram row and column clues
colclues = [["#"] for i in range(COLS)]
rowclues = [["#"] for i in range(ROWS)]

#testing code
colclues[1] = ["1", "2", "2"]
rowclues[3] = ["2", "3", "2"]


# labels the rows for the nonogram
# for clues with multiple elements (ex. 1,2,2 on same row), automatically spaces each clue (onto a new line in a column or adds spacing in a row)
for i in range (COLS):
    for k in range (len(colclues[i])):
        gamewindow.create_text(40*(i+1.5) + (bordersize - 40), (bordersize - 30) + (10 * (k)), text=colclues[i][k])
        
for j in range (ROWS):
    for l in range (len(rowclues[j])):
        gamewindow.create_text((bordersize - 20) + (7 * (l)), 40*(j+1.5) + (bordersize - 40), text=rowclues[j][l])

root.mainloop()
